/**
 * Auto-generated from UCP JSON Schema
 * Source: /Users/kilic/Dev/universal-commerce-protocol/ucp/spec/schemas/shopping/order.json
 * Schema ID: https://ucp.dev/schemas/shopping/order.json
 *
 * DO NOT EDIT MANUALLY - This file is auto-generated
 * To update: Run `bun run schemas:generate` from ucp-doctor root
 *
 * Generated: 2026-01-16T11:38:45.514Z
 */


import { z } from "zod"

/**
 * Order
 * 
 * Order schema with immutable line items, buyer-facing fulfillment expectations, and append-only event logs.
 */
export const OrderSchema = z.object({ "ucp": z.object({ "version": z.string().regex(new RegExp("^\\d{4}-\\d{2}-\\d{2}$")).describe("UCP protocol version in YYYY-MM-DD format."), "capabilities": z.array(z.intersection(z.object({ "name": z.string().regex(new RegExp("^[a-z][a-z0-9]*(?:\\.[a-z][a-z0-9_]*)+$")).describe("Stable capability identifier in reverse-domain notation (e.g., dev.ucp.shopping.checkout). Used in capability negotiation.").optional(), "version": z.any().describe("Capability version in YYYY-MM-DD format.").optional(), "spec": z.string().url().describe("URL to human-readable specification document.").optional(), "schema": z.string().url().describe("URL to JSON Schema for this capability's payload.").optional(), "extends": z.string().regex(new RegExp("^[a-z][a-z0-9]*(?:\\.[a-z][a-z0-9_]*)+$")).describe("Parent capability this extends. Present for extensions, absent for root capabilities.").optional(), "config": z.record(z.any()).describe("Capability-specific configuration (structure defined by each capability).").optional() }), z.any()).describe("Capability reference in responses. Only name/version required to confirm active capabilities.")).describe("Active capabilities for this response.") }).describe("UCP metadata for order responses. No payment handlers needed post-purchase."), "id": z.string().describe("Unique order identifier."), "checkout_id": z.string().describe("Associated checkout ID for reconciliation."), "permalink_url": z.string().url().describe("Permalink to access the order on merchant site."), "line_items": z.array(z.object({ "id": z.string().describe("Line item identifier."), "item": z.object({ "id": z.string().describe("Should be recognized by both the Platform, and the Business. For Google it should match the id provided in the \"id\" field in the product feed."), "title": z.string().describe("Product title."), "price": z.number().int().gte(0).describe("Unit price in minor (cents) currency units."), "image_url": z.string().url().describe("Product image URI.").optional() }).describe("Product data (id, title, price, image_url)."), "quantity": z.object({ "total": z.number().int().gte(0).describe("Current total quantity."), "fulfilled": z.number().int().gte(0).describe("Quantity fulfilled (sum from fulfillment events).") }).describe("Quantity tracking. Both total and fulfilled are derived from events."), "totals": z.array(z.any()).describe("Line item totals breakdown."), "status": z.enum(["processing","partial","fulfilled"]).describe("Derived status: fulfilled if quantity.fulfilled == quantity.total, partial if quantity.fulfilled > 0, otherwise processing."), "parent_id": z.string().describe("Parent line item identifier for any nested structures.").optional() })).describe("Immutable line items â€” source of truth for what was ordered."), "fulfillment": z.object({ "expectations": z.array(z.object({ "id": z.string().describe("Expectation identifier."), "line_items": z.array(z.object({ "id": z.string().describe("Line item ID reference."), "quantity": z.number().int().gte(1).describe("Quantity of this item in this expectation.") })).describe("Which line items and quantities are in this expectation."), "method_type": z.enum(["shipping","pickup","digital"]).describe("Delivery method type (shipping, pickup, digital)."), "destination": z.object({ "extended_address": z.string().describe("An address extension such as an apartment number, C/O or alternative name.").optional(), "street_address": z.string().describe("The street address.").optional(), "address_locality": z.string().describe("The locality in which the street address is, and which is in the region. For example, Mountain View.").optional(), "address_region": z.string().describe("The region in which the locality is, and which is in the country. Required for applicable countries (i.e. state in US, province in CA). For example, California or another appropriate first-level Administrative division.").optional(), "address_country": z.string().describe("The country. Recommended to be in 2-letter ISO 3166-1 alpha-2 format, for example \"US\". For backward compatibility, a 3-letter ISO 3166-1 alpha-3 country code such as \"SGP\" or a full country name such as \"Singapore\" can also be used.").optional(), "postal_code": z.string().describe("The postal code. For example, 94043.").optional(), "first_name": z.string().describe("Optional. First name of the contact associated with the address.").optional(), "last_name": z.string().describe("Optional. Last name of the contact associated with the address.").optional(), "full_name": z.string().describe("Optional. Full name of the contact associated with the address (if first_name or last_name fields are present they take precedence).").optional(), "phone_number": z.string().describe("Optional. Phone number of the contact associated with the address.").optional() }).describe("Delivery destination address."), "description": z.string().describe("Human-readable delivery description (e.g., 'Arrives in 5-8 business days').").optional(), "fulfillable_on": z.string().describe("When this expectation can be fulfilled: 'now' or ISO 8601 timestamp for future date (backorder, pre-order).").optional() }).describe("Buyer-facing fulfillment expectation representing logical groupings of items (e.g., 'package'). Can be split, merged, or adjusted post-order to set buyer expectations for when/how items arrive.")).describe("Buyer-facing groups representing when/how items will be delivered. Can be split, merged, or adjusted post-order.").optional(), "events": z.array(z.object({ "id": z.string().describe("Fulfillment event identifier."), "occurred_at": z.string().datetime({ offset: true }).describe("RFC 3339 timestamp when this fulfillment event occurred."), "type": z.string().describe("Fulfillment event type. Common values include: processing (preparing to ship), shipped (handed to carrier), in_transit (in delivery network), delivered (received by buyer), failed_attempt (delivery attempt failed), canceled (fulfillment canceled), undeliverable (cannot be delivered), returned_to_sender (returned to merchant)."), "line_items": z.array(z.object({ "id": z.string().describe("Line item ID reference."), "quantity": z.number().int().gte(1).describe("Quantity fulfilled in this event.") })).describe("Which line items and quantities are fulfilled in this event."), "tracking_number": z.string().describe("Carrier tracking number (required if type != processing).").optional(), "tracking_url": z.string().url().describe("URL to track this shipment (required if type != processing).").optional(), "carrier": z.string().describe("Carrier name (e.g., 'FedEx', 'USPS').").optional(), "description": z.string().describe("Human-readable description of the shipment status or delivery information (e.g., 'Delivered to front door', 'Out for delivery').").optional() }).describe("Append-only fulfillment event representing an actual shipment. References line items by ID.")).describe("Append-only event log of actual shipments. Each event references line items by ID.").optional() }).describe("Fulfillment data: buyer expectations and what actually happened."), "adjustments": z.array(z.object({ "id": z.string().describe("Adjustment event identifier."), "type": z.string().describe("Type of adjustment (open string). Typically money-related like: refund, return, credit, price_adjustment, dispute, cancellation. Can be any value that makes sense for the merchant's business."), "occurred_at": z.string().datetime({ offset: true }).describe("RFC 3339 timestamp when this adjustment occurred."), "status": z.enum(["pending","completed","failed"]).describe("Adjustment status."), "line_items": z.array(z.object({ "id": z.string().describe("Line item ID reference."), "quantity": z.number().int().gte(1).describe("Quantity affected by this adjustment.") })).describe("Which line items and quantities are affected (optional).").optional(), "amount": z.number().int().describe("Amount in minor units (cents) for refunds, credits, price adjustments (optional).").optional(), "description": z.string().describe("Human-readable reason or description (e.g., 'Defective item', 'Customer requested').").optional() }).describe("Append-only event that exists independently of fulfillment. Typically represents money movements but can be any post-order change. Polymorphic type that can optionally reference line items.")).describe("Append-only event log of money movements (refunds, returns, credits, disputes, cancellations, etc.) that exist independently of fulfillment.").optional(), "totals": z.array(z.object({ "type": z.enum(["items_discount","subtotal","discount","fulfillment","tax","fee","total"]).describe("Type of total categorization."), "display_text": z.string().describe("Text to display against the amount. Should reflect appropriate method (e.g., 'Shipping', 'Delivery').").optional(), "amount": z.number().int().gte(0).describe("If type == total, sums subtotal - discount + fulfillment + tax + fee. Should be >= 0. Amount in minor (cents) currency units.") })).describe("Different totals for the order.") }).describe("Order schema with immutable line items, buyer-facing fulfillment expectations, and append-only event logs.")
export type OrderSchema = z.infer<typeof OrderSchema>
