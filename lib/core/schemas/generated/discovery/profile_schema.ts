/**
 * Auto-generated from UCP JSON Schema
 * Source: /Users/kilic/Dev/universal-commerce-protocol/ucp/spec/discovery/profile_schema.json
 * Schema ID: https://ucp.dev/schemas/discovery/profile.json
 *
 * DO NOT EDIT MANUALLY - This file is auto-generated
 * To update: Run `bun run schemas:generate` from ucp-doctor root
 *
 * Generated: 2026-01-16T11:38:45.554Z
 */


import { z } from "zod"

/**
 * UCP Discovery Profile
 * 
 * Schema for UCP discovery profile returned from /.well-known/ucp.
 */
export const ProfileSchemaSchema = z.object({ "ucp": z.object({ "version": z.string().regex(new RegExp("^\\d{4}-\\d{2}-\\d{2}$")).describe("UCP protocol version in YYYY-MM-DD format."), "services": z.record(z.object({ "version": z.any().describe("Service version in YYYY-MM-DD format."), "spec": z.string().url().describe("URL to service documentation. Origin MUST match namespace authority."), "rest": z.object({ "schema": z.string().url().describe("URL to OpenAPI 3.x specification (JSON format)"), "endpoint": z.string().url().describe("Merchant's REST API endpoint") }).describe("REST transport binding").optional(), "mcp": z.object({ "schema": z.string().url().describe("URL to OpenRPC specification (JSON format)"), "endpoint": z.string().url().describe("Merchant's MCP endpoint") }).describe("MCP transport binding").optional(), "a2a": z.object({ "endpoint": z.string().url().describe("Merchant's Agent Card endpoint") }).describe("A2A transport binding").optional(), "embedded": z.object({ "schema": z.string().url().describe("URL to OpenRPC specification (JSON format) defining the embedded protocol") }).describe("Embedded transport binding (JSON-RPC 2.0 over postMessage). Unlike REST/MCP, the endpoint is per-capability (i.e. per-checkout via continue_url), not per-service.").optional() }).catchall(z.any()).describe("Schema for UCP service definitions. A service defines the API surface for a vertical (shopping, common, etc.) with transport bindings.")).describe("Service definitions keyed by reverse-domain service name."), "capabilities": z.array(z.intersection(z.object({ "name": z.string().regex(new RegExp("^[a-z][a-z0-9]*(?:\\.[a-z][a-z0-9_]*)+$")).describe("Stable capability identifier in reverse-domain notation (e.g., dev.ucp.shopping.checkout). Used in capability negotiation.").optional(), "version": z.any().describe("Capability version in YYYY-MM-DD format.").optional(), "spec": z.string().url().describe("URL to human-readable specification document.").optional(), "schema": z.string().url().describe("URL to JSON Schema for this capability's payload.").optional(), "extends": z.string().regex(new RegExp("^[a-z][a-z0-9]*(?:\\.[a-z][a-z0-9_]*)+$")).describe("Parent capability this extends. Present for extensions, absent for root capabilities.").optional(), "config": z.record(z.any()).describe("Capability-specific configuration (structure defined by each capability).").optional() }), z.any()).describe("Full capability declaration for discovery profiles. Includes spec/schema URLs for agent fetching.")).describe("Supported capabilities and extensions.") }).describe("Full UCP metadata for /.well-known/ucp discovery."), "payment": z.object({ "handlers": z.array(z.object({ "id": z.string().describe("The unique identifier for this handler instance within the payment.handlers. Used by payment instruments to reference which handler produced them."), "name": z.string().describe("The specification name using reverse-DNS format. For example, dev.ucp.delegate_payment."), "version": z.any().describe("Handler version in YYYY-MM-DD format."), "spec": z.string().url().describe("A URI pointing to the technical specification or schema that defines how this handler operates."), "config_schema": z.string().url().describe("A URI pointing to a JSON Schema used to validate the structure of the config object."), "instrument_schemas": z.array(z.string().url().describe("A URI pointing to a schema definition (e.g., JSON Schema) used to validate the structure of the instrument object.")), "config": z.record(z.any()).describe("A dictionary containing provider-specific configuration details, such as merchant IDs, supported networks, or gateway credentials.") })).describe("Payment handler definitions that describe how instruments can be collected").optional() }).describe("Payment configuration containing handlers").optional(), "signing_keys": z.array(z.object({ "kid": z.string().describe("Key ID. Referenced in signature headers to identify which key to use for verification."), "kty": z.string().describe("Key type (e.g., 'EC', 'RSA')."), "crv": z.string().describe("Curve name for EC keys (e.g., 'P-256').").optional(), "x": z.string().describe("X coordinate for EC public keys (base64url encoded).").optional(), "y": z.string().describe("Y coordinate for EC public keys (base64url encoded).").optional(), "n": z.string().describe("Modulus for RSA public keys (base64url encoded).").optional(), "e": z.string().describe("Exponent for RSA public keys (base64url encoded).").optional(), "use": z.enum(["sig","enc"]).describe("Key usage. Should be 'sig' for signing keys.").optional(), "alg": z.string().describe("Algorithm (e.g., 'ES256', 'RS256').").optional() })).describe("Public keys for signature verification (JWK format). Used to verify signed responses, webhooks, and other authenticated messages from this party.").optional() }).catchall(z.any()).describe("Schema for UCP discovery profile returned from /.well-known/ucp.")
export type ProfileSchemaSchema = z.infer<typeof ProfileSchemaSchema>
